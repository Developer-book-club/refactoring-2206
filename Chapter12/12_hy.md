# 12 상속 다루기 

## 12.1 메서드 올리기 Pull Up Method

메서드 올리기를 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다. 이럴 땐 그냥 복사해 붙여넣으면 끝이다. 물론 세상이 언제나 이처럼 만만하지는 않다. 
메서드 올리기 리팩터링을 적용하려면 선행 단계를 거쳐야 할 때가 많다. 예컨대 서로 다른 두 클래스의 두 메서드를 각각 매개변수화하면 궁극적으로 같은 메서드가 되기도 한다. 이런 경우에 가장 적은 단계를 거쳐 리팩터링하려면 각각의 함수를 매개변수화한 다음 메서드를 상속 계층의 위로 올리면 된다.

## 12.2 필드 올리기 Pull Up Field

서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕 있다. 특히 필드가 중복되기 쉽다. 이런 필드들은 이름이 비슷한 게 보통이지만, 항상 그런 것은 아니다. 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자.
이렇게 하면 두 가지 중복을 줄일 수 있다. 첫째, 데이터 중복 선언을 없앨 수 있다. 둘째, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.

## 12.3 생성자 본문 올리기 Pull Up Constructor Body

서브클래스들에서 기능이 같은 메서드를 발견하면 함수 추출하기와 메서드 올리기를 차례로 적용하여 말끔히 슈퍼클래스로 옮기곤 한다. 그런데 그 메서드가 생성자라면 스텝이 꼬인다. 생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.

## 12.4 메서드 내리기 Push Down Method

특정 서브클래스 하나와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스에 추가하는 편이 깔끔하다. 다만, 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무엇인지를 호출자가 알고 있을 때만 적용할 수 있다.

## 12.5 필드 내리기 Push Down Field

서브클래스 하나에서만 사용하는 필드는 해당 서브클래스로 옮긴다.

## 12.6 타입 코드를 서브클래스로 바꾸기 Replace Type Code with Subclasses

서브클래스는 두 가지 면에서 특히 매력적이다. 첫째, 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다. 타입 코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 특히 유용하다. 서브클래스를 이용하면 이런 함수들에 조건부 로직을 다형성으로 바꾸기를 적용할 수 있다.
두 번째 매력은 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다. 예컨대 '판매 목표'는 '영업자' 유형일 때만 의미가 있다. 이런 상황이라면 서브클래스를 만들고 필요한 서브클래스만 필드를 갖도록 정리하자.

## 12.7 서브클래스 제거하기 Remove Subclass

서브클래싱은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다. 다름을 프로그래밍하는 멋진 수단인 것이다. 하지만 소프트웨어 시스템이 성장함에 따라 서브클래스로 만든 변종이 다른 모듈로 이동하거나 완전히 사라지기도 하면서 가치가 바래기도 한다. 서브클래스는 결국 한 번도 활용되지 않기도 하며, 때론 서브클래스를 필요로 하지 않는 방식으로 만들어진 기능에서만 쓰이기도 한다.

## 12.8 슈퍼클래스 추출하기 Extract Superclass

비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다. 공통된 부분이 데이터라면 필드 올리기를 활용하고, 동작이라면 메서드 올리기를 활용하면 된다.

## 12.9 계층 합치기 Collapse Hierarchy

클래스 계층구조를 리팩터링하다 보면 기능들을 위로 올리거나 아래로 내리는 일은 다반사로 벌어진다. 예컨대 계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다. 바로 그 둘을 하나로 합쳐야 할 시점이다.

## 12.10 서브클래스를 위임으로 바꾸기 Replace Subclass with Delegate

속한 갈래에 따라 동작이 달라지는 객체들은 상속으로 표현하는 게 자연스럽다. 공통 데이터와 동작은 모두 슈퍼클래스에 두고 서브클래스는 자신에 맞게 기능을 추가하거나 오버라이드하면 된다. 객체 지향 언어로는 이런 형태로 구현하기가 쉽기 때문에 흔히 활용되는 메커니즘이다.
하지만 상속에는 단점이 있다. 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에는 그 중 단 하나의 이유만 선택해 기준으로 삼을 수 밖에 없다. 예컨대 사람 객체의 동작을 '나이대'와 '소득 수준'에 따라 달리 하고 싶다면 서브클래스는 젊은이와 어르신이 되거나, 혹은 부자와 서민이 되어야 한다. 둘 다는 안된다.
또 다른 문제로 상속은 클래스들의 관계를 아주 긴밀하게 결합한다. 부모를 수정하면 이미 존재하는 자식들의 기능을 헤치기가 쉽기 때문에 각별히 주의해야 한다. 그래서 자식들이 슈퍼클래스를 어떻게 상속해 쓰는지를 이해해야 한다. 부모와 자식이 서로 다른 모듈에 속하거나 다른 팀에서 구현한다면 문제는 더 커진다.

위임 delegate은 이상의 두 문제를 모두 해결해준다. 다양한 클래스에 서로 다른 이유로 위임할 수 있다. 위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의 할 수 있다. 즉 상속보다 결합도가 훨씬 약하다. 그래서 서브클래싱 관련 문제에 직면하게 되면 흔히들 서브클래스를 위임으로 바꾸곤 한다.

유명한 원칙이 하나 있다. 상속보다는 컴포지션을 사용하라 여기서 컴포지션은 사실상 위임과 같은 말이다. 많은 사람이 이 말을 상속은 위험하다고 받아들여서 상속을 사용하면 절대 안 된다고 주장하기도 한다. 하지만 나는 상속을 자주 사용하는데, 이렇게 하는 배경에는 나중에라도 필요하면 언제든 서브클래스를 위임으로 바꿀 수 있음을 알고 있다는 점이 한 몫 한다. 그래서 처음에는 상속으로 접근한 다음, 문제가 생기기 시작하면 위임으로 갈아탄다. 이 방식은 사실 앞의 원칙과도 일맥상통한다. 

## 12.11 슈퍼클래스를 위임으로 바꾸기 Replace Superclass with Delegate

객체 지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단이다. 기존 클래스를 상속하여 입맛에 맞게 오버라이드하거나 새 기능을 추가하면 된다. 하지만 상속이 혼란과 복잡도를 키우는 방식으로 이뤄지기도 한다. 
상속을 잘못 적용한 예로는 자바의 스택 클래스가 유명하다. 자바의 스택은 리스트를 상속하고 있는데, 데이터를 저장하고 조작하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과다. 재활용이란 관점에서는 좋았지만 이 상속에는 문제가 있다. 리스트의 연산 중 스택에는 적용되지 않는 게 많음에도 그 모든 연산이 스택 인터페이스에 그대로 노출되는 게 아닌가. 이보다는 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 더 멋졌을 것이다.
자바의 스택은 슈퍼클래스를 위임으로 바꾸는 이번 리팩터링을 적용해야 하는 좋은 예다. 슈퍼클래스의 기능들이 서브클래스에는 어울리지 않는다면 그 기능들을 상속을 통해 이용하면 안된다는 신호다.

# 퀴즈

상속과 컴포지션의 차이?