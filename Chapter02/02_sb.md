
# 2장. 리팩터링 원칙

# 리팩터링 정의

지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 `리팩터링` 이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 **특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.**

- 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

# 기능추가 vs 리팩터링

- 저자는 소프트웨어 개발시 `기능추가`와 `리팩터링`을 명확히 구분해서 작업한다고 하심.
- `기능추가` 를 할 때는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 하고, `리팩터링` 할때는 기능추가는 절대 하지 않으며 오로지 코드 재구성에만 전념한다.
    - 리팩터링시, (놓친 테스트 케이스를 발견하지 않는한) 테스트도 새로 만들지 않는다.

# 리팩터링 하는 이유

1. 소프트웨어 설계가 좋아진다.
2. 소프트웨어를 이해하기 쉬워진다.
3. 버그를 쉽게 찾을 수 있다.
4. 프로그래밍 속도를 높일 수 있다.

# 리팩터링을 해야하는 시점

1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
    
    > 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
    > 
2. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
3. 쓰레기 줍기 리팩터링
    
    > 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링 이다.
    > 
4. 계획된 리팩터링과 수시로 하는 리팩터링
    
    > 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른일을 하는 중에 처리한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
    > 
5. 오래 걸리는 리팩터링
    
    > 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다. 리팩터링이 코드를 깨트리지 않는다는 장점 활용!
    > 
6. 코드리뷰에 리팩터링 활용하기
    
    > 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다.
    > 
7. 관리자에게는 뭐라고 말해야 할까?
    
    > 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하길 원한다. 기능을 빠르게 구현하는 가장 빠른 방법은 리팩터링이다.
    > 
8. 리팩터링하지 말아야 할 때 ⭐️
    
    1) 지저분한 코드를 발견해도, 굳이 수정할 필요가 없는 경우
    
    - 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
    
    2) 리팩터링하는 것보다 처음부터 새로 작성하는게 쉬울 때
    
    - 그러나 직접 리팩터링 해보기 전에 결정을 내리기는 쉽지 않다.

# 리팩터링시 고려할 문제

1. 리팩터링 vs  클린코드(clean code)
    - 리팩터링을 클린코드나 바람직한 엔지니어링 습관 처럼 도덕적인 이유로 정당화 해서는 안된다. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는데 있지 않다. 오로직 경제적인 이유로 하는 것이다.
    - 리팩터링의 궁극적 목표는 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것
2. 코드 소유권
    - 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.
    - 그러므로 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대한다. 코드의 소유권을 팀에 두고, 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 해야 한다.
3. 지속적  통합(Continuous Integration) / 트렁크 기반 개발(TBD. Trunk-Based Development)
    - 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리하면 머지 복잡도를 줄일 수 있고, 리팩터링과 궁합도 좋다(코드가 깨지지 않음).
    - 익스트림 프로그래밍(XP. eXtreme Programming)
        - 지속적 통합 - 자가 테스트코드 - 리팩터링 등 상호 의존하는 기법들을 하나로 묶은 프로세스
    - 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용 가능. CI/CD의 핵심이다.
4. 레거시 코드
    - 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움 된다.
    - 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이다.
5. 현재까지의 요구사항만을 해결하는 소프트웨어 구축
    - 간결한 설계, 점진적 설계, YAGNI(You Aren’t Going to Need It), 진화형 아키텍처
    - 코딩 전에 아키텍처를 확정지으려면 소프트웨어 요구사항을 사전에 모두 파악해야 한다. → 실현 불가능
    - 유연성 메커니즘(flexibility mechanism)이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다.
        - ex) 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가
        - 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 매커니즘 추가

# 리팩터링과 성능

- 먼저, 성능을 측정해봐야 한다.
    - 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아내야 한다.
    - 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은노력으로 큰 효과를 볼 수 있다.
- 성능 저하를 일으키는 곳은 전체 코드 중 극히 일부분일 가능성이 높다.
    - = 코드 전체를 고르게 최적화한다면, 90%정도는 효과가 없어 시간낭비가 될 수 있다.
- 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 리팩토링에 집중한다.