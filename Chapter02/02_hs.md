## 핵심 문장

- **두개의 모자 - ‘기능 추가’와 ‘리팩토링’**
  하나를 할 때에는 절대 다른 것은 건드리지 않는다
- **리팩토링하는 이유**
  1. 소프트웨어 설계가 좋아짐
  2. 소프트웨어를 이해도 향상
  3. 빠른 디버깅

     ⇒ 프로그래밍 속도 향상
  - 단지 다른 사람을 배려하기 위해서가 아니다. 사실 그 다른 사람이 바로 나 자신일 때가 많다. 그래서 더더욱 리팩토링이 중요하다.
- **3의 법칙**
  1. 처음엔 그냥 한다
  2. 비슷하게 두 번째로 하게 되면 일단 계속 진행한다.
  3. 세 번째 하게 되면 리팩토링한다.
- **수시로 하는 리팩토링**
  - 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자 (켄트 백)
  - 잘 작성된 코드 역시 수많은 리팩토링을 거쳐야 한다. 어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다.
  - 오랫동안 사람들은 소프트웨어 개발이란 뭔가 ‘추가’하는 과정으로 여겼다.
    하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 ‘수정’하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
- **리팩토링 시 고려할 문제**
  1. 새 기능 개발 속도 저하
     - 리팩토링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것임.
       리팩토링의 본질이 코드 베이스를 예쁘게 꾸미는 것이 아니라 경제적인 이유라는 것을 잊지 말 것.
  2. 코드 소유권
     - 코드 소유권이 엄격하게 나뉘어 있으면 개선에 제약이 생김
       따라서 소유권을 느슨하게 하여 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 할 것
  3. 브랜치
     - 한 브랜치에 모든 기능 구현을 하고 완성되면 머지하기보다는
       기능을 잘게 쪼개 머지 주기를 짧게 하는 CI(Continuous Integration) 방식 적용
     - CI + 리팩토링 = XP(eXtreme Programming, 익스트림 프로그래밍)
  4. 테스팅
     - 자가 테스트 코드를 마련할 것
       이를 통해 오류를 빨리 잡을 수 있음
  5. 레거시 코드
     - 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰져있지 않음
       테스트 보강을 통해 레거시 시스템을 파악하고 개선할 것
  6. 데이터베이스
     - 커다란 변경을 독립된 단계로 쪼개 순차적으로 연결할 것
     - 프로덕션 환경에 여러 단계로 나눠 릴리스하는 것이 좋다는 점에서 다른 리팩터링과 차별성 존재
- **YAGNI = You Aren’t Going To Need It**
  - 현재 파악한 요구사항만을 해결하는 코드 설계
  - 복잡도를 높일 수 있는 유연성 메커니즘(향후 변경에 대처할 수 있도록 미리 대비해 설계하는 것)은 반드시 검증을 거친 후 추가함
    추측에 근거한 유연성 매커니즘을 갖춘 시스템보다 단순한 시스템이 변경하기 훨씬 쉬움
- **TDD(Test Driven Development, 테스트 주도 개발)**
  - 자가 테스트 코드 + 리팩토링 = TDD
  - 자가 테스트 코드 + CI + 리팩토링 ⇒ 강력한 상승효과!
- **리팩토링과 성능**
  - 리팩토링은 성능 좋은 소프트웨어를 만드는 데 기여함.
    단기적으로는 리팩터링 단계에서 성능이 느려질 수 있지만 최적화 단계에서 코드 튜닝이 쉬워지므로 결국 더 빠른 소프트웨어를 얻게 됨.
  - 최적화의 90%는 시간낭비
    성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비함
    코드 전체를 최적화한다면 그 중 90%는 효과가 거의 없는 시간낭비라는 것.
    따라서 최적화 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 것에 집중하고 이후 튜닝하자.
