# 조건부 로직 간소화

## 10.1 조건문 분해하기 Decompose Conditional

거대한 코드 블록이 주어지면 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수 호출로 바꿔주자. 그러면 전체적인 의도가 더 확실히 드러난다.

## 10.2 조건식 통합하기 Consolidate Conditional Expression

비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 더러 있는데, 어차피 같은 일을 할 거라면 조건 검사도 하나로 통합하는 게 낫다. 이럴 때 and 연산자와 or 연산자를 사용하면 여러 개의 비교 로직을 하나로 합칠 수 있다.

조건부 코드를 통합하는게 중요한 이유는 두 가지다. 

1. 여러 조각으로 나뉜 조건들을 하나로 통합함으로써 내가 하려는 일이 명확해진다. 나눠서 순서대로 비교해도 결과는 같지만, 읽는 사람은 독립된 검사들이 우연히 함께 나열된 것으로 오해할 수 있다.

2.  이 작업이 함수 추출하기까지 이어질 가능성이 높기 때문. 함수 추출하기는 '무엇'을 하는지를 기술하던 코드를 '왜' 하는지를 말해주는 코드로 바꿔주는 효과적인 도구임을 기억하자

## 10.3 중첩 조건문을 보호 구문으로 바꾸기 Replace Nested Conditional with Guard Clauses

조건문은 주로 두 가지 형태로 쓰인다. 참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태와, 한쪽만 정상인 형태다.

두 경로 모두 정상 동작이라면 if와 else절을 사용하고, 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나온다. 두 번째 검사 형태를 흔히 보호 구문(guard clause)이라고 한다.

중첩 조건문을 보호 구문으로 바꾸기 리팩토링의 핵심은 의도를 부각하는 데 있다.

## 10.4 조건부 로직을 다형성으로 바꾸기 Replace Conditional with Polymorphism

복잡한 조건부 로직은 프로그래밍에서 해석하기 가장 난해한 대상에 속한다. 
타입을 여러 개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 처리하도록 구성하는 방법이 있다. 다형성을 활용하여 어떻게 동작할지를 각 타입이 알아서 처리하도록 하면 된다.

또 다른 예로 기본 동작을 위한 case문과 그 변형 동작으로 구성된 로직을 떠올릴 수 있다. 기본 동작은 가장 일반적이거나 가장 직관적인 동작일 것이다. 먼저 이 로직을 슈퍼클래스로 넣어서 변형 동작에 신경 쓰지 않고 기본에 집중하게 한다. 그런 다음 변형 동작을 뜻하는 case들을 각각의 서브클래스로 만든다. 이 서브클래스들은 기본 동작과의 차이를 표현하는 코드로 채워질 것이다.

## 10.5 특이 케이스 추가하기 Introduce Special Case

데이터 구조의 특정 값을 확인한 후 똑같은 동작을 수행하는 코드가 곳곳에 등장하는 경우가 더러 있는데, 흔히 볼 수 있는 중복 코드 중 하나다. 이처럼 코드베이스에서 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이라면 그 반응들을 한 데로 모으는 게 효율적이다.

특수한 경우의 공통 동작을 요소 하나에 모아서 사용하는 특이 케이스 패턴이라는 것이 있는데, 바로 이럴 때 적용하면 좋은 메커니즘이다. 이 패턴을 활용하면 특이 케이스를 확인하는 코드 대부분을 단순한 함수 호출로 바꿀 수 있다.

## 10.6 어서션 추가하기 Introduce Assertion

어서션은 항상 참이라고 가정하는 조건부 문장으로, 어서션이 실패했다는 건 프로그래머가 잘못했다는 뜻이다.
어서션 실패는 시스템의 다른 부분에서는 절대 검사하지 않아야 하며, 어서션이 있고 없고가 프로그램 기능의 정상 동작에 아무런 영향을 주지 않도록 작성돼야 한다. 

한편, 어서션을 남발하는 것 역시 위험하다. 나는 참이라고 생각하는 가정 모두에 어서션을 달지는 않는다. ' 반드시 참이어야 하는' 것만 검사한다. 프로그래머가 일으킬만한 오류에만 어서션을 사용하는 것이 좋다. 데이터를 외부에서 읽어 온다면 그 값을 검사하는 작업은 어서션이 아니라 예외 처리로 대응해 프로그램 로직의 일부로 다뤄야 한다. 

# 퀴즈

10장의 어떤 리팩토링 기법이랑 잘 매칭 된다고 생각하시나요? 

**개방폐쇄의 원칙 : OCP (Open Close Principle)**

> SOLID의 O에 해당하는 원칙으로 소프트웨어의 모든 구성요소(클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야한다는 원칙입니다. 다시 말하면 요구사항의 변경이나 추가사항의 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야하며 쉽게 확장이 가능하여 재사용할 수 있어야 한다는 뜻입니다. 로버트 마틴은 OCP는 관리가 용이하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요한 메커니즘은 추상화(Abstraction)와 다형성(Polymorphism)이라고 설명합니다. OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리입니다.








