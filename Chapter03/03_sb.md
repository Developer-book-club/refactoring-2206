# 3장. 코드에서 나는 악취

# introduction

> 냄새 나면 당장 갈아라
- 캔트 벡 할머니의 육아 원칙
> 

리팩터링을 ‘언제' 적용해야 하는지에 대해서는 명확하게 정립된 규칙이 없다.

이번 장에서 소개하는 24개의 ‘악취'를 알고있다가, 악취가 나면 리팩터링 할 시점이라고 판단하면 된다.

# 24개의 악취들

## 1. 기이한 이름(Mysterious Name)

> 함수 선언 바꾸기, 변수이름 바꾸기, 필드 이름 바꾸기
> 
- 코드를 명료하게 표현하는데 가장 중요한 요소는 바로 ‘이름'이다.
- 마땅한 이름이 떠오르지 않는다면 설계에 문제가 있을 가능성이 높다.

## 2. 중복 코드(Duplicated Code)

> 함수 추출하기, 문장 슬라이드하기, 메서드 올리기
> 
- 함수 추출하기: 두 메서드가 똑같은 코드를 사용하는 경우
- 문장 슬라이드하기: 코드가 비슷하긴 한데 완전히 똑같지는 않은 경우
- 메서드 올리기: 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있는 경우

## 3. 긴 함수(Long Function)

> 함수 추출하기, 임시변수를 질의함수로 바꾸기, 매개변수 객체 만들기, 객체 통째로 넘기기, 함수를 명령으로 바꾸기, 조건문 분해하기, 조건부 로직을 다형성으로 바꾸기, 반복문 쪼개기
> 
- 오랜기간 잘 활용되는 프로그램들은 짦은 함수로 구성되어 있다.
- `간접 호출(indirection)`의 효과
    - 함수를 짧게 구성할때, 코드를 이해/공유/선택하기 쉬워진다.
- 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
- 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
- 함수의 길이가 아닌, 목적(의도)와 구현코드의 괴리가 얼마나 큰지가 중요하다. ‘무엇을 하는지'를 코드가 잘 설명해주지 못할 수록 함수로 만드는 게 유리하다.

## 4. 긴 매개변수 목록(Long Parameter List)

> 매개변수를 질의 함수로 바꾸기, 객체 통째로 넘기기, 매개변수 객체 만들기, 플래그 인수 제거하기, 여러 함수를 클래스로 묶기
> 
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

## 5. 전역 데이터(Global Data)

> 변수 캡슐화하기
> 
- 지독한 악취중 하나
- 전역 데이터는 코드베이스 어디에서든 건들일 수 있어, 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 가장 큰 문제다.
- 클래스 변수와 싱글톤에서도 전역 데이터와 같은 문제가 발생한다.

## 6. 가변 데이터(Mutable Data)

> 변수 캡슐화하기, 변수 쪼개기, 문장 슬라이드하기, 함수 추출하기, 질의 함수와 변경 함수 분리하기, 세터 제거하기, 파생변수를 질의 함수로 바꾸기, 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기, 참조를 값으로 바꾸기
> 
- 데이터 변경시, 예상치 못한 결과나 버그로 이어지는 경우가 있다. 아주 드문 조건에서 발생한다면 원인을 알아내기가 더 어렵다.
- 이런 이유로 함수형 프로그래밍에서는 side-effect가 없음을 기본으로 삼고있

## 7. 뒤엉킨 변형(Divergent Change)

> 단계 쪼개기, 함수 옮기기, 함수 추출하기, 클래스 추출하기
> 
- 단일 책임 원칙(SRP. Single Responsibility Principle)이 제대로 지켜지지 않을때 나타난다.
    - 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을 때

## 8. 산탄총 수술(Shotgun Surgery)

> 함수 옮기기, 필드 옮기기, 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기, 단계 쪼개기, 함수 인라인하기, 클래스 인라인 하기
> 
- 뒤엉킨 변형과 비슷하면서도 정반대의 악취
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우 나타난다.
    - 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

## 9. 기능 편애(Feature Envy) ✅

> 함수 옮기기, 함수 추출하기
> 
- 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 나타난다.
- 보통 프로그램을 모듈화 할때, 코드를 여러 영역으로 나누는데, 같은 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 다른 영역간의 상호작용은 최소로 줄이는데 주력한다.

## 10. 데이터 뭉치(Data Clumps)

> 클래스 추출하기, 매개변수 객체 만들기, 객체 통째로 넘기기
> 
- 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 한다.
- 데이터 뭉치인지 판별하는 법
    - 값 하나를 삭제해보고, 나머지 데이터만으로는 의미가 없다면 데이터 뭉치이다.
- 데이터 뭉치는 간단한 레코드 구조가 아닌 ‘클래스'로 만들기를 권장한다.
- 기능 편애 + 데이터 뭉치를 함께 연계하면 좋다.

## 11. 기본형 집착(Primitive Obsession)

> 기본형을 객체로 바꾸기, 타입 코드를 서브클래스로 바꾸기, 조건부 로직을 다형성으로 바꾸기, 클래스 추출하기, 매개변수 객체 만들기
> 
- 화폐, 좌표, 구간과 같은 현재 필요한 타입에 대해 직접 정의하기를 몹시 꺼리는 경우가 많다.
- `문자열화된 변수(stringly typed)`: 특성에 맞게 자료형을 구성하지 않고 문자열로만 표현하는 것

## 12. 반복되는 switch문(Repeated Switches)

> 조건부 로직을 다형성으로 바꾸기
> 
- 중복된 switch문은 문제가 된다.
    - 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 한다.

## 13. 반복문(Loops)

> 반복문을 파이프라인으로 바꾸기
> 
- 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있

## 14. 성의 없는 요소(Lazy Element)

> 함수 인라인하기, 클래스 인라인하기, 계층 합치기
> 
- 본문 코드를 그대로 쓰는 것과 다를것 없는 함수의 경우
- 실질적으로 메서드가 하나뿐인 클래스

## 15. 추측성 일반화(Speculative Generality)

> 계층 합치기, 함수 인라인하기, 클래스 인라인하기, 함수 선언 바꾸기, 죽은 코드 제거하기
> 
- ‘나중에 필요할 거야’ 라는 생각으로 당장은 필요 없는 모든 종류의 후킹(hocking) 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 나타난다.

## 16. 임시 필드(Temporary Field) ✅

> 클래스 추출하기, 함수 옮기기, 특이 케이스 추가하기
> 
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스
    - 객체를 가져오는 입장에서는 모든 필드가 채워져 있으리라 기대하는게 보통이라 임시 필드를 갖도록 작성하면 코드 이해가 어려움.

## 17. 메시지 체인(Message Chains) ✅

> 위임 숨기기, 함수 추출하기, 함수 옮기기
> 
- 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
    - 중간 단계를 수정했을 경우 문제 발생할 수 있음.
- 메서드 체인이 무조건 나쁜것은 아니다. (?)

## 18. 중개자(Middle Man) ✅

> 중개자 제거하기, 함수 인라인하기
> 
- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우
    - 캡슐화하는 과정에서는 위임(delegation)이 자주 활용 된다. 그치만 위임이 지나칠 경우 문제가 된다.

## 19. 내부자 거래(Insider Trading)

> 함수 옮기기, 필드 옮기기, 위임 숨기기, 서브클래스 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기
> 
- 모듈 사이의 데이터 거래가 많으면 결합도(coupling)가 높아진다.
    - 결합도를 최소로 줄이는 것이 좋다.

## 20. 거대한 클래스(Large Class)

> 클래스 추출하기, 슈퍼클래스 추출하기, 타입코드를 서브클래스로 바꾸기
> 
- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다.
    - 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
- 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다.

## 21. 서로다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfaces)

> 함수 선언 바꾸기, 함수 옮기기, 슈퍼클래스 추출하기
> 
- 클래스를 사용할 떄의 가장 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 점.
    - 단, 교체하려면 인터페이스가 같아야 함.

## 22. 데이터 클래스(Data Class) ✅

> 레코드 캡슐화 하기, 세터 제거하기, 함수 옮기기, 함수 추출하기, 단계 쪼개기
> 
- 데이터 클래스: 데이터 필드와 getter/setter 메서드로만 구성된 클래스
- * 데이터 클래스는 데이터 저장 용도로만 쓰이다보니 다른 클래스가 너무 깊이까지 다루는 경우가 있음.
- 불변 필드는 굳이 캡슐화 할 필요가 없고, 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.

## 23. 상속 포기(Refused Bequest)

> 메서드 내리기, 필드 내리기, 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기
> 
- 서브클래스는 기본적으로 부모로부터 메서드와 데이터를 물려받는데, 필요하고 관심있는 유산 몇개만 받고 싶은 경우
    - 메서드 내리기, 필드 내리기
    - 같은 계층에 서브클래스를 하나 새로 만들고, 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 그러면 부모는 공통 부분만 남는다.
        - but, 이 방식을 항상 권장하는 것은 아님.
        - 상속을 포기할 시 혼란과 문제가 생긴다면 예전 방식을 따른다.
- 서브 클래스가 부모의 동작은 필요로하지만, 인터페이스는 따르고 싶지 않을때
    - 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기

## 24. 주석(Comments)

> 함수 추출하기, 함수 선언 바꾸기, 어서션 추가하기
> 
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 떄문인 경우가 의외로 많다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 업슨 코드로 리팩터링 해본다.