# 3장 - 코드에서 나는 악취

### 1) 기이한 이름

- 코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나가 바로 ‘이름’
  이름만 보고도 무슨 일을 하는지 명확히 알 수 있도록 신경써서 이름 지어야 함.

### 2) 중복 코드

- 똑같은 코드 구조가 반복된다면 하나로 통합할 것

### 3) 긴 함수

- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나옴
  간접 호출의 효과!
- 함수 이름이 코드의 목적을 드러내야 함
  ’무엇을 하는지’를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리함

### 4) 긴 매개변수 목록

- **해결**
  매개변수를 질의 함수로 바꾸기
  객체 통째로 넘기기
  매개변수 객체 만들기
  플래그 인수 제거하기
  여러 함수를 클래스로 묶기

### 5) 전역 데이터

- 가장 지독한 악취 중 하나
  어디에서든 건드릴 수 있고 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제
- **해결 -** 변수 캡슐화

### 6) 가변 데이터

- 함수형 프로그래밍에서는 원본 데이터가 아닌 복사본을 반환해 데이터 가공

### 7) 뒤엉킨 변경

- 단일 책임 원칙(하나의 모듈은 변경의 이유가 하나여야 함)이 지켜지지 않을 때 발생
- 한 코드에 섞여들어감
- **해결 -** 맥락별로 분리

### 8) 산탄총 수술

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때
- 7. 뒤엉킨 변경의 정반대
- 여러 코드에 흩뿌려짐
- **해결 -** 맥락별로 모음

### 9) 기능 편애

- 어떤 함수가 자기가 속한 모듈이 아닌 다른 영역의 함수나 데이터와 상호작용이 더 많을 때
- 프로그램을 모듈화할 때는 영역 내에서 상호작용은 최대, 영역 간 상호작용은 최소로 줄여야 함

### 10) 데이터 뭉치

- 데이터들이 뭉쳐 있는 것

### 11) 기본형 집착

- 기본 타입에 대한 강박관념을 갖고 직접 정의하기를 꺼리는 것

### 12) 반복되는 switch문

- 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아 함께 수정해야 하는 문제 발생
- **해결 -** 조건부 로직을 다형성으로 바꾸기

### 13) 반복문

- **해결** - 반복문을 파이프라인으로 바꾸기
  ex) map, filter

### 14) 성의 없는 요소

- **해결** - 함수/클래스 인라인하기, 계층 합치기 등

### 15) 추측성 일반화

- 미래를 대비해 만들었지만 당장은 사용하는 곳이 없는 코드

### 16) 임시 필드

- 특정 상황에서만 값이 설정되는 필드

### 17) 메시지 체인

- 다른 객체를 요청하는 작업이 연속적으로 이어지는 코드
- **해결** - 위임 숨기기

### 18) 중개자

- 캡슐화 과정에서 지나친 위임

### 19) 내부자 거래

- 모듈 사이 데이터 거래가 많은 것
- 결합도(coupling)가 높아지므로 이를 최소로 줄이고 투명하게 처리해야 함

### 20) 거대한 클래스

- 한 클래스가 너무 많은 일을 하는 경우 필드가 늘어나고 중복 코드가 생기기 쉬움

### 21) 서로 다른 인터페이스의 대안 클래스들

- 서로 다른 클래스의 메서드가 하는 일이 비슷한 경우

### 22) 데이터 클래스

- 데이터 필드와 게터/세터 메서드로만 구성된 클래스
- 데이터 저장 용도로만 쓰이므로 다른 클래스가 함수로 다룰 때가 많음
- 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있음

### 23) 상속 포기

- 부모 클래스의 메서드와 데이터를 필요로 하지 않는 경우
- 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 경우

### 24) 주석

- 장황하게 달린 주석보단 주석이 필요없는 코드로 리팩토링 할 것
- 적절한 주석은 악취가 아닌 향기를 입힘
