# Chapter 08

기능이동

## 8.1 Move Function

- 어떤 함수가 자신이 속한 모듈 A의 요소들보다 다른 모듈 B의 요소들을 더 많이 참조한다면 모듈 B로 옮겨줘야 마땅하다. 이렇게 하면 캡슐화가 좋아져서, 이 소프트웨어의 나머지 부분은 모듈 B의 세부사항에 덜 의존하게 된다.

- 함수를 옮길지 말지를 정하기란 쉽지 않다. 그럴 땐 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보면 도움이 된다. 대상 함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 또 무엇이 있는지, 대상 함수가 사용하는 데이터는 무엇인지를 살펴봐야 한다.

## 8.2 Move Field

- 프로그램의 상당 부분이 동작을 구현하는 코드로 이뤄지지만 프로그램의 진짜 힘은 데이터 구조에서 나온다. 

- 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 할 것이다.

## 8.3 Move Statements into Function

- 특정 함수를 호출하는 코드가 나올 때마다 그 앞이나 뒤에서 똑같은 코드가 추가로 실행되는 모습을 보면, 나는 그 반복되는 부분을 피호출 함수로 합치는 방법을 궁리한다. 이렇게 해두면 추후 반복되는 부분에서 무언가 수정할 일이 생겼을 때 단 한곳만 수정하면 된다.

- 나중에 이 코드의 동작을 여러 변형들로 나눠야 하는 순간이 오면 반대 리팩터링인 문장을 호출한 곳으로 옮기기를 적용하여 쉽게 다시 뽑아 낼 수 있다.

## 8.4 Move Statements to Callers

- 함수는 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록이다. 그런데 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다.

## 8.5 Replace Inline Code with Function Call

- 함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때문에 함수를 활용하면 코드를 이해하기가 쉬워진다.

- 이름을 잘 지었다면 인라인 코드 대신 함수 이름을 넣어도 말이 된다.

## 8.6 Slide Statements

- 관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다.

- 관련 코드끼리 모으는 작업은 다른 리팩토링의 준비 단계로 자주 행해진다.

## 8.7 Split Loop

- 반복문 하나에서 두 가지 일을 수행하면 수정해야 할 때마다 두 가지 일 모두를 잘 이해하고 진행해야 한다. 반대로 각각의 반복문으로 분리해두면 수정할 동작 하나만 이해하면 된다.

- 반복문 쪼개기는 서로 다른 일들이 한 함수에서 이뤄지고 있다는 신호일 수 있고, 그래서 반복문 쪼개기와 함수 추출하기는 연이어 수행하는 일이 잦다.

- 반복문 쪼개기가 다른 더 강력한 최적화를 적용할 수 있는 길을 열어주기도 한다.

## 8.8 Replace Loop with Pipeline

- 논리를 파이프라인으로 표현하면 이해하기 훨씬 쉬워진다. 객체가 파이프라인을 따라 흐르며 어떻게 처리되는지를 읽을 수 있기 때문이다.

## 8.9 Remove Dead Code

# Chapter 09

## 9.1 Split Variable

- 대입이 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다. 역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다.

## 9.2 Rename Field

- 게터와 세터 메서드는 클래스 사용자 입장에서는 필드와 다를 바 없다.

## 9.3 Replace Derived Variable with Query

- 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.

## 9.4 Change Reference to Value

- 특정 객체를 여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 한다.

- 값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.

## 9.5 Change Value to Reference

- 논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 그 데이터를 갱싱해야 할 때다. 모든 복제본을 찾아서 빠짐없이 갱신해야 하며, 하나라도 놓치면 데이터 일관성이 깨져버린다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는게 좋다.

## 9.6 Replace Magic Literal

- 매직 리터럴이란 소스 코드에 등장하는 일반적인 리터럴 값


# 퀴즈

1. 9.3 Replace Derived Variable with Query

```js
get production() {return this._production;}
applyAdjustment(anAdjustment) {
    this._adustments.push(anAdjustment);
    this._production += anAdjustment.amount
}
```

여기서 파생변수는 무엇이고 어떻게 바꿀 수 있는가?
(복습)


2. photoData 함수를 쓰는곳이 5곳이 있고 함수를 호출하는 모든 곳에서 

```js
result.push('<p> 제목: ${person.photo.title}</p>')
```

이런 코드가 함께 쓰인다면 어떤 리팩토링 기법을 쓰는 것이 좋은가?


```js
result.push('<p> 제목: ${person.photo.title}</p>')
result.concat(photoData(person.photo))

function photoData(aPhoto) { 
    return [
        '<p>위치: ${aPhoto.location}</p>',
        '<p>날짜: ${aPhoto.date.toDateString()}</p>', 
    ];
}



```
